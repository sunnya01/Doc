##### JAVA学习第五天

###### 多线程实现方式

1.继承Thread类重写run方法 2.实现Runnable接口实现run方法3.实现Callable接口实现call方法

区分: 

1 比较基础略过

2 将多线程需要执行的逻辑进行独立的类包装，与方法1不同的是，可以将该类的实例对象进行多次线程的启动，

3 通过泛型，可以将动态的设置返回类型，在多线程的线程对象绑定启动后，并在后续通过FuturTask的实例对象进行处理结果读取

###### 多线程的安全机制

1. synchronized(Object obj){  } 同步代码块,本质通过任何对象的的父类Object的未知锁属性，某个线程进入时对改对象的堆空间的该属性进行赋值，其他线程进入如果发型该属性存在值，则进行堵塞

2. synchronized void method(){} 同步方法，与同步代码块本质是一样的，只不过同步方法如果是静态方法，则对本类的静态锁属性进行判断，如果是实例方法则对调用该方法的当前实例对象也就是this对象进行锁属性的判断，值得一提的是如果是同步方法的形式，则当前类中的所有同步方法共享一个锁，也就是A线程进入了该类的s1同步方法，则B线程如果想要执行该类的s2同步方法也需要等待，应为他们都是基于当前类的锁属性实现同步的

3. lock接口，通过ReentrantLock的实例对象，它本质实现了lock接口(该锁定原理依然是同上基于实例对象或者静态类的锁属性实现)，在方法内可以自由的使用lock对象.lock();方法进行锁定，或者.unlock();方法解锁能够更好在一个方法内动态的结合具体逻辑进行加锁解锁比较推荐的保证线程安全的方法

   

###### 多线程安全机制下的死锁以及sleep(),wait()的区分

死锁造成的原因，对同一个同步代码块进行不同线程的操作时，如果涉及到对多个对象的锁定访问则会有可能造成互锁的问题

例：1线程在他的异步方法体内执行A逻辑需要锁定obj1对象，执行完A逻辑后再执行B逻辑，B逻辑需要锁定obj2对象

2线程在他的异步方法体内执行C逻辑需要锁定obj2对象，执行完C逻辑后再执行B逻辑，D逻辑需要锁定obj1对象,则有概率会发生

1线程执行完A逻辑时，由于在等待被2线程C逻辑锁定的obj2对象时发生堵塞，导致它对obj1一直占用，从而影响2线程的D逻辑需要对obj1锁定是一直无法继续

因此双发在互相等待中发生死锁

